
# Introduction to algorithms - Peak search (1D)

這次介紹的是`Peak finding`，簡單講，就是找出比鄰居大的元素。比方說，數列`[1, 3, 2]` `Peak`就是3, 數列 `[3, 2, 1]`, Peak就是`index` 爲 0 的 3, 數列 `[1, 2, 3]`, `Peak`是`index` 爲 `2` 的 `3`

如果只是要找到數列中其中一個`Peak`, 複雜度想不到竟然是一個比n還要少的`O(log n)`!

我一開始的想法總是無腦的暴力破解(汗)，認為 `index 1` 之後(含)的元素需要比兩次， 以數列 `[1, 2, 3, 4]` 而言，2 這個數字需要跟前面的比，也需要跟後面得比才能知道是否為 `Peak`, e.g. $${ (i > i - 1)}$$ and $${ (i > i + 1)}$$, 這兩個條件都成立才是`Peak`, 當時只有想到，不需比兩次，只需依序比過，再反轉 $${< or > }$$ 符號即可。e.g. $${1<2}$$,  $${2>3}$$, 要檢查3時，只需要比較$${3 < 4}$$即可，因為前面已經記錄$${3 < 2}$$了。這樣複雜度是$${O(n)}$$。

但我缺少更進一步的分析，比方說有沒有什麼方法可以不用每個都比？如果這個比出來不是，往哪個方向更容易找到？一般第一個想法就是這個不是，應該往一下一個找。

## 解法

任何一個 $${x}$$, 他有兩個可能, 要麻他是`peak`, 要麻不是。這麼簡單的道理我竟然就是沒想到。再次忽略Base case，檢討檢討。

若$${x}$$是`peak`, 回傳$${x}$$即可，可用$${x}$$是否比前後都大檢查。若不是`Peak`, 那有兩個可能。

1. $${x}$$ 比前面小或$${x}$$比後面小,` [4, 2, 1, 3]` , 如果是這樣，該怎麼從這個僅有的資訊推敲出Peak會在哪邊？

這時候一定要想到一句話，**如果現在是黑夜，表示就快黎明了**，正因為要找的是`peak`, **所以如果你在山下，看坡在哪邊就往那邊走**。

以 `[4, 2, 1, 3] `這個數列來講， 若取 2 當 $${x}$$ , `4 > 2`, 因此往**4**的方向比往**1**的方向更有機會。

就是這個**mindset**, 得到再某些條件下應該要往哪走的資訊了。而最後的解法就是用**binary search**, 在 $${x}$$ 不是`peak`時，找出下一個 $${x}$$。
